

## 1.小球自由落体

一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第n次落地时，共经过多少米？第n次反弹多高？

数据范围： 1≤�≤100 1≤*n*≤100 

时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M

输入描述：

```
一行，一个整数n (1<=n<=10)。
```

输出描述：

```
输出两个浮点数ans1,ans2。ans1为第n次落地时，共经过的距离；ans2为第n次反弹的高度。答案应与标准答案误差小于1e-5。两个数间以空格相间。
```

示例1

输入例子：

```
1
```

输出例子：

```
100.000000 50.000000
```

示例2

输入例子：

```
10
```

输出例子：

```
299.609375 0.097656
```

```cpp
#include <iostream>
#include<iomanip>
#include<array>
using namespace std;

int main() {
    int n;
    array<double, 10> ans1 = {100}, ans2 = {50};
    for (int i = 1; i < 10; i ++) {
        ans1[i] = ans1[i - 1] + ans2[i - 1] * 2;
        ans2[i] = ans2[i - 1] / 2;
    }
    //加入setiosflags(ios::fixed)   设置浮点数以固定的小数位数显示
    //加入setprecision(n)  设置浮点数有效数字
    while (cin >> n) {
        cout << setiosflags(ios::fixed) << setprecision(6) << ans1[n - 1] << " " << ans2[n - 1] << endl;
    }
    return 0;
}

```



## 2.序号4

2.

序号4

有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。

时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M

输入描述：

```
一行，一个正整数n（1<=n<=1000000）。
```

输出描述：

```
输出答案。
```

示例1

输入例子：

```
5
```

输出例子：

```
4
```

例子说明：

```
出局的编号依次为3,1,5,2，最后留下的是4
```

分析：

> 纯模拟，TC为$O(n*3)$.可能会超时。
>
> | n    | 结果 | 结果-1 |
> | ---- | ---- | ------ |
> | 1    | 1    | 0      |
> | 2    | 2    | 1      |
> | 3    | 2    | 1      |
> | 4    | 1    | 0      |
> | 5    | 4    | 3      |
> | 6    | 1    | 0      |
> | 7    | 4    | 3      |
> | 8    | 7    | 6      |
> | 9    | 1    | 0      |
> | 10   | 4    | 3      |
> | 11   | 7    | 6      |
> | 12   | 10   | 9      |
> | 13   | 13   | 12     |
> | 14   | 2    | 1      |
> | 15   | 5    | 4      |
> | 16   | 8    | 7      |
> | 17   | 11   | 10     |
> | 18   | 14   | 13     |
> | 19   | 17   | 16     |
> | 20   | 20   | 19     |
> | 21   | 2    | 1      |
> | 22   | 5    | 4      |
> | 23   | 8    | 7      |
>
> nextRes = (res + 3) % n

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    while (cin >> n) {
        int res = 0;
        for (int i = 1; i <= n; i ++) {
            res = (res + 3) % i;
        }
        cout << res + 1 << endl;
    }
    return 0;
}
```





## 3.序号5

小陆每天要写一份工作日报，日报标题含有日期。几年后，他翻开以前的日报，想知道两份日报的日期是否同为星期几，请编程帮助他判断。

时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M

输入描述：

```
第一行一个正整数T(1<=T<=100)。表示有T个测试样例。
接下来T行，每一行有6个正整数y1,m1,d1,y2,m2,d2,（以空格相间）。其中y1-m1-d1分别为第一个日期的年月日，y2-m2-d2分别为第二个日期的年月日。（满足1970<=y1,y2<=9999, 1<=m1,m2<=12, 1<=d1,d2<=31,且保证两个日期是合法的）。
```

输出描述：

```
输出T行，对应T个答案。对于每一行，如果两个日期在同一周，输出“True”；否则输出“False”（输出内容不含双引号）。
```

示例1

输入例子：

```
2
1970 1 2 2020 2 7
2020 1 1 2020 1 2
```

输出例子：

```
True
False
```

例子说明：

```
1970-1-2和2020-2-7同为星期五
```

分析：

> 注意边界问题。
>
> 基姆拉尔森计算公式。
>
> - https://www.nowcoder.com/questionTerminal/0aee85ede971476ab503753f468be5df
> - https://www.cnblogs.com/10134dz/p/13710459.html

## 4.序号6

段誉身具凌波微波，动无常则，若危若安，一次能走一级台阶或者两级台阶，他要爬一段30级的山路，问有多少种走法？分析如何计算，然后编程解答。
进阶问题：当他轻功熟练度提升，一次最多可以走三级，那就结果有什么变化？后来走火入魔了，不能走一级，只能走二或三级，又有什么变化？

时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M

输入描述：

```
输入一个数n（1<=n<=30），代表段誉要爬一段n级的山路。
```

输出描述：

```
输出三个整数a,b,c（以空格相间）。其中a为段誉一次能走一级或两级台阶的走法；b为段誉一次能走一级、二级或三级台阶的走法；c为段誉一次能走二级或三级台阶的走法。
```

示例1

输入例子：

```
3
```

分析：

找出初始值，以及对应的数学表达式即可。

```cpp
#include <iostream>
#include <iomanip>
#include <array>
#include <list>
using namespace std;
const int MAXN = 30 + 1;

int main() {
    int n;
    // ans1, ans2, ans3
    array<int, MAXN> ans1, ans2, ans3;
    ans1[1] = 1, ans1[2] = 2, ans1[3] = 3;
    ans2[1] = 1, ans2[2] = 2, ans2[3] = 4;
    ans3[1] = 0, ans3[2] = 1, ans3[3] = 1;
    // ans1[i] = ans1[i-1] + ans1[i-2], i >= 2;
    // ans2[i] = ans2[i-1] + ans2[i-2] + ans2[i-3], i >= 3;
    // ans3[i] = ans3[i-2] + ans3[i-3], i >= 3;
    for (int i = 4; i < MAXN; i ++) {
        ans1[i] = ans1[i-1] + ans1[i-2];
        ans2[i] = ans2[i-1] + ans2[i-2] + ans2[i-3];
        ans3[i] = ans3[i-2] + ans3[i-3];
    }
    while (cin >> n) {
        cout << ans1[n] << " " << ans2[n] << " " << ans3[n] << endl;
    }
    return 0;
}
```

