https://leetcode.cn/problems/container-with-most-water/

> 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
>
> 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。
>
> 说明：你不能倾斜容器。
>
>  
>
> 示例 1：
>
> ![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)
>
> 输入：[1,8,6,2,5,4,8,3,7]
> 输出：49 
> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
> 示例 2：
>
> 输入：height = [1,1]
> 输出：1
>
>
> 提示：
>
> n == height.length
> 2 <= n <= 105
> 0 <= height[i] <= 104
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/container-with-most-water
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

分析：这道题在今年的实习 腾讯云智一面的时候问到过，所以印象比较深。

上来感觉这道题比较符合滑动窗口的特点，简单说就是**固定一端，滑动另一端（两端相遇或者不合法状态时结束循环）**

具体到这道题就是，将题目理解成求面积， 面积就有长宽之积，长是题中两个柱子之间的距离，宽（**高**）也就是 **两个柱子中较矮的一个柱子的高度**。然后问在所给数组heights中，能够形成的最大面积是多少？ **按照自己的想法理清题意很重要！**

其实到这里，能够形成矩形有 `n * (n - 1)`个，很明显，这是暴力解法，不会是我们以及出题者想要的。那么我们需要利用到题目的隐藏信息，一个是长度，如果让长度从相邻为1开始遍历，是一个暴力解；**那么我们考虑将两根柱子的左右起点分别出于最左和最右端，然后往中间滑动遍历呢？ **再一个是， **两个柱子中较矮的那个**，拿示例1来说，较矮的柱子是右边的7，那么如果说我们想要这个面积更大（虽然我们已知它是所给最大面积了），我们要么让长度更长（**左边的柱子左移**），要么让较矮的柱子更高（**右边的柱子左移**），前者由于柱子起点在最左右端，所以不会再往回走，那么只有后者才可能让这个面积更大。到这里，这就是滑动窗口的一个解题思想了。

```c++
// 示例1解释： l所处的位置->,  r所处的位置<-
//1,  8,  6,  2,  5,  4,  8,  3,  7			size = 9, l = 0, r = 8, res = 0
//->                              <-		length = 8, width = 1		  8
//    ->                          <-				 7			7		  49（此时为最大面积，即为所求）
//	  ->					  <-					 6			3 		  49
//    ->				  <-						 5          8         49
//	  ->			  <-							 4 			4	      49
//	  ->		  <-								 3			5		  49
// 	  ->	  <-									 2			2		  49
// 	  ->  <-										 1			6		  49

// TC/SC: O(n)/O(1)
class Solution {
public:
    int maxArea(vector<int>& height) {
        int size = height.size();
        int l = 0, r = size - 1, res = 0;
        while (l < r) {
            int lengh = r - l, width;
            if (height[l] < height[r]) {
                width = height[l];
                ++ l;
            } else {
                width = height[r];
                -- r;
            }
            res = max(res, lengh * width);
        }
        return res;
    }
};
```

